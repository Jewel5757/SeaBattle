/* Представление. Обновляет изображение маркерами
 попаданий и промахов, а также сообщениями для пользователя.*/
let view = {
    displayMessage: function(msg) {
    let messageArea = document.getElementById("messageArea"); //Используем DOM для получения элемента с идентификатором “messageArea”.
    messageArea.innerHTML = msg; //Задает свойству innerHTML элемента сообщение, переданное методу displayMessage.
    },
    displayHit: function(location) {   //Получаем строковый идентификатор из двух цифр, определяющих координаты клетки для вывода маркера промаха/попадания.
    let cell = document.getElementById(location); //Используем DOM для получения элемента с полученным идентификатором.
    cell.setAttribute("class", "hit");
    },
    displayMiss: function(location) {
    let cell = document.getElementById(location);
    cell.setAttribute("class", "miss");
    }
   };


/* Модель.следит за кораблями: где они находятся,
 попали ли в них и не утонули ли подстреленные корабли.*/
    
    let model = {
        boardSize: 7,
        numShips: 3,
        shipsSunk: 0,
        shipLength: 3,
        shipLength: 3,
        ships: [ { locations: [0, 0, 0], hits: ["", "", ""] },
                 { locations: [0, 0, 0], hits: ["", "", ""] },
                 { locations: [0, 0, 0], hits: ["", "", ""] } ],
fire: function(guess) {   //Проверяет каждый корабль и узнает, занимает ли он указанную клетку.
        for (let i = 0; i < this.numShips; i++) {  //перебираем массив ships, последовательно проверяя каждый корабль.
        let ship = this.ships[i]; //Здесь мы получаем объект корабля. Необходимо проверить, совпадают ли координаты выстрела с координатами одной из занимаемых им клеток
        let index = ship.locations.indexOf(guess); //Получаем массив клеток, занимаемых кораблем и проверяем есть ли там позиция с выстрелом
            if (index >= 0) { //Если клетка присутствует в списке позиций, значит, выстрел попал в цель. Программа помечает соответствующий элемент массива hits (и сообщает представлению о попадании). Метод возвращает true — признак попадания
            ship.hits[index] = "hit";
            view.displayHit(guess);//Оповещаем представление о том, что в клетке guess следует вывести маркер попадания.
            view.displayMessage("Попал!"); // и чтобы представление вывело сообщение о попадании
                if (this.isSunk(ship)) 
                    {
                    view.displayMessage("Вы потопили мой корабль!");
                    this.shipsSunk++;
                    }
                return true;
                }

        }
            view.displayMiss(guess);  //Если указанная клетка не занята кораблем, значит, игрок промахнулся. Мы сообщаем об этом представлению и возвращаем false.
            view.displayMessage("Ха-ха, промах");
            return false;
        },
isSunk: function(ship) { //Метод с именем isSunk получает объект корабля и возвращает true, если корабль потоплен, или false, если он еще держится на плаву.
        for (let i = 0; i < this.shipLength; i++) { //Метод получает объект корабля и проверяет, помечены ли все его клетки маркером попадания.
            if (ship.hits[i] !== "hit") { //Если есть хотя бы одна клетка, в которую еще не попал игрок, то корабль еще жив и метод возвращает false.
            return false;
                }
            }
            return true;
        },

/*основной метод. Создает в модели массив ships с
количеством кораблей, определяемым свойством numShips модели.*/        
generateShipLocations: function() {
    let locations;
        for (let i = 0; i < this.numShips; i++) {//Для каждого корабля генерируется набор позиций, то есть занимаемых клеток.
            do {
            locations = this.generateShip(); //Генерируем новый набор позиций.
            } while
            (this.collision(locations));
            /*Проверяем, перекрываются ли эти позиции с существующими 
            кораблями на доске. Если есть перекрытия, нужна еще одна попытка.
            Новые позиции генерируются, пока не будут найдены варианты без перекрытий.*/
            this.ships[i].locations = locations; //Полученные позиции без перекрытий сохраняются в свойстве locations объекта корабля в массиве model.ships.
        }
},

/*метод создает один корабль, находящийся в произвольном месте игрового поля.
 При этом не исключено перекрытие с другими кораблями.*/
generateShip: function() {
    let direction = Math.floor(Math.random() * 2); //Генерируем число от 0 до 1 и умножаем результат на 2, чтобы получить число в диапазоне от 0 до 2 (не включая 2). Затем Math.floor преобразует результат в 0 или 1.
    let row, col;
    if (direction === 1) { //Если значение direction равно 1, создается горизонтальный корабль.
    //Этот код генерирует начальную позицию корабля на игровом поле->
    row = Math.floor(Math.random() * this.boardSize); //Горизонтальный корабль может располагаться в любой строке.
    col = Math.floor(Math.random() * (this.boardSize - this.shipLength)); //...но при выборе первого столбца нужно оставить место для других клеток.
    } else {
    row = Math.floor(Math.random() * (this.boardSize - this.shipLength));
    col = Math.floor(Math.random() * this.boardSize);
    }
    let newShipLocations = []; //Набор позиций нового корабля начинается с пустого массива, в который последовательно добавляются элементы.
    for (let i = 0; i < this.shipLength; i++) { //В цикле до количества позиций в корабле.
    if (direction === 1) {
        newShipLocations.push(row + "" + (col + i));
     /*<-Данные  массива состоят из строки (начальной, вычисленной выше).
    И столбца + i. При первой итерации i равно 0, и сумма обозначает начальный столбец.
    При второй итерации происходит переход к следующему столбцу, а при третьей — 
    к следующему за ним. Так в массиве генерируются серии элементов “01”, “02”, “03”.*/
    } else {
        newShipLocations.push((row + i) + "" + col);
    }
    }
    return newShipLocations; //Когда все позиции сгенерированы, метод возвращает массив методу generateShipLocations.
},

/*метод получает один корабль и проверяет, 
что тот не перекрывается с кораблями, уже находящимися на игровом поле.*/
collision: function(locations) { //locations — массив позиций нового корабля, который мы собираемся разместить на игровом поле.
    for (let i = 0; i < this.numShips; i++) {
    let ship = model.ships[i];
    for (let j = 0; j < locations.length; j++) { //...проверить, встречается ли какая-либо из позиций массива locations нового корабля в массиве locations существующих кораблей.
    if (ship.locations.indexOf(locations[j]) >= 0) { //Метод indexOf проверяет, присутствует ли заданная позиция в массиве. Таким образом, если полученный индекс больше либо равен 0, мы знаем, что клетка уже занята, поэтому метод возвращает true (перекрытие обнаружено).
    return true;
    }
    }
    }
    return false; //Если выполнение дошло до этой точки, значит, ни одна из позиций не была обнаружена в других массивах, поэтому функция возвращает false (перекрытия отсутствуют).
    }
};

function parseGuess(guess) {
    let alphabet = ["A", "B", "C", "D", "E", "F", "G"]; //Массив заполняется всеми буквами, которые могут присутствовать в действительных координатах.
        if (guess === null || guess.length !== 2) { //Проверяем данные на null и убеждаемся, что в строке два символа.
            alert("Введите корректное число и букву!");
        } else {
            firstChar = guess.charAt(0); //Извлекаем первый символ строки.
            let row = alphabet.indexOf(firstChar); //При помощи метода indexOf получаем цифру в диапазоне от 0 до 6, соответствующую букве.
            let column = guess.charAt(1);//Код для получения второго символа, представляющего столбец игрового поля.
        if (isNaN(row) || isNaN(column)) { //функция isNaN выявляет строки и столбцы, которые не являются цифрами.
            alert("Введите корректное число и букву!");
        } else if (row < 0 || row >= model.boardSize ||
            column < 0 || column >= model.boardSize) {
            alert("Введите корректное число и букву!");
        } else {
            return row + column; //Строка и столбец объединяются, а результат возвращается методом. Здесь снова зад ействовано преобразование типа: row — число, а column — строка, поэтому результаТом также является строка.
        }
        }
        return null; //Если управление передано в эту точку, значит, какая-то проверка не прошла, и метод возвращает null.
        }

/* Контроллер. 1. Получение и обработка координат выстрела (например, “A0” или “B1”).
2. Отслеживание количества выстрелов.
3. Запрос к модели на обновление в соответствии с последним выстрелом.
4. Проверка завершения игры (когда все корабли будут потоплены).*/
let controller = {
    guesses: 0,
    processGuess: function(guess) { //Начало метода processGuess, получающего координаты в формате “A0".
    let location = parseGuess(guess);
            if (location) { //Если метод не возвращает null, значит, был получен действительный объект location.
            this.guesses++; //Если пользователь ввел правильные координаты, счетчик выстрелов увеличивается на 1.
        let hit = model.fire(location);
        if (hit && model.shipsSunk === model.numShips) {
        view.displayMessage("Вы потопили все корабли за " + //Если выстрел попал в цель, а количество потопленных кораблей равно количеству кораблей в игре, выводится сообщение о том, что все корабли потоплены.
        this.guesses + " попыток" +"!");
        }
            }
    }
};

function init() {
    let fireButton = document.getElementById("fireButton"); //Получаем ссылку на кнопку Fire! по идентификатору кнопки:
    fireButton.onclick = handleFireButton; //Кнопке можно назначить обработчик события нажатия — функцию handleFireButton.
    guessInput.onkeydown = handleKeyPress; //Обработчик — для обработки событий нажатия клавиш в поле ввода HTML.
    model.generateShipLocations(); //Вызов метода, генерирующего позиции кораблей, который заполнит пустые массивы в объекте модели.
}

/*Получение координат от формы
и передача их контроллеру. */
function handleFireButton() {  
    let guessInput = document.getElementById("guessInput"); ////Получаем ссылку на элемент формы по идентификатору элемента, “guessInput”.
    let guess = guessInput.value; //Затем извлекаем данные, введенные пользователем. Координаты хранятся в свойстве value элемента input.
    controller.processGuess(guess); //Координаты выстрела передаются  контроллеру
    guessInput.value = ""; //Короткая команда просто удаляет содержимое элемента input формы, заменяя его пустой строкой.
}

/*
Обработчик нажатий клавиш; вызывается при каждом нажатии клавиши в поле input страницы.
Браузер передает объект события обработчику. Объект содержит информацию о том,
какая клавиша была нажата.
*/
function handleKeyPress(e) { 
    let fireButton = document.getElementById("fireButton"); 
    if (e.keyCode === 13) {
        /*Если нажата клавиша Enter,
        то свойство keyCode события равно 13. В таком случае кнопка Fire!
        должна сработать так, словно игрок щелкнул на ней. Для этого
        можно вызвать метод click кнопки fireButton (фактически этот вызов
        имитирует нажатие кнопки).*/
    fireButton.click();
    return false; //возвращаем false, чтобы форма не делала ничего лишнего
    }
    }
    window.onload = init;